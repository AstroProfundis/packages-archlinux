Only in openonload-201210-u2_patched/: openonload-201210-u2-bug37560_3.10.compat.patch
Only in openonload-201210-u2_patched/: openonload-201210-u2-bug37722_3.10_postponed_fput_ooops.patch
Only in openonload-201210-u2_patched/scripts: build
Only in openonload-201210-u2_patched/scripts: setup.py
diff -ur openonload-201210-u2_orig/src/driver/linux_affinity/sfcaffinity.c openonload-201210-u2_patched/src/driver/linux_affinity/sfcaffinity.c
--- openonload-201210-u2_orig/src/driver/linux_affinity/sfcaffinity.c	2013-07-25 14:33:11.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_affinity/sfcaffinity.c	2013-09-27 10:08:52.000000000 +0100
@@ -38,6 +38,53 @@
 MODULE_AUTHOR("Solarflare Communications");
 MODULE_LICENSE("GPL");
 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+#ifdef RHEL_MAJOR
+static inline struct proc_dir_entry *
+proc_create_data(const char *name, umode_t mode,
+         struct proc_dir_entry *parent,
+         const struct file_operations *proc_fops,
+         void *data)
+{
+    struct proc_dir_entry *pde;
+    pde = proc_create(name, mode, parent, proc_fops);
+    if (pde != NULL)
+        pde->data = data;
+    return pde;
+}
+#else
+static inline struct proc_dir_entry *
+proc_create_data(const char *name, umode_t mode,
+		 struct proc_dir_entry *parent,
+		 const struct file_operations *proc_fops,
+		 void *data)
+{
+	struct proc_dir_entry *pde;
+	pde = create_proc_entry(name, mode, parent);
+	if (pde != NULL) {
+		pde->proc_fops = (struct file_operations *)proc_fops;
+		pde->data = data;
+	}
+	return pde;
+}
+static inline struct proc_dir_entry *
+proc_create(const char *name, umode_t mode,
+		 struct proc_dir_entry *parent,
+		 const struct file_operations *proc_fops)
+{
+	return proc_create_data(name, mode, parent, proc_fops, NULL);
+}
+#endif
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+static inline void *PDE_DATA(const struct inode *inode)
+{
+	return PROC_I(inode)->pde->data;
+}
+#endif
+
+
 #ifndef NIPQUAD
 # define NIPQUAD(addr) \
     ((unsigned char *)&addr)[0], \
@@ -98,60 +145,78 @@
 }
 
 
-static int aff_proc_read_int(char *page, char **start, off_t off, int count, 
-			     int *eof, void *data)
+static int aff_proc_read_int(struct seq_file *seq, void *s)
+{
+	int *pint = seq->private;
+	seq_printf(seq, "%d\n", *pint);
+	return 0;
+}
+static int aff_proc_open_int(struct inode *inode, struct file *file)
 {
-	int *pint = data;
-	int n = 0;
-	n += snprintf(page + n, count - n, "%d\n", *pint);
-	*eof = 1;
-	return n;
+	return single_open(file, aff_proc_read_int, PDE_DATA(inode));
 }
+static const struct file_operations aff_proc_fops_int = {
+	.owner		= THIS_MODULE,
+	.open		= aff_proc_open_int,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 
-static int aff_proc_read_cpu2rxq(char *page, char **start, off_t off,
-				 int count, int *eof, void *data)
+static int aff_proc_read_cpu2rxq(struct seq_file *seq, void *s)
 {
 	/* ?? fixme: this really needs to grab [lock] */
-	struct aff_interface *intf = data;
+	struct aff_interface *intf = seq->private;
 	int n_cpus = num_online_cpus();
-	int i, n = 0;
+	int i;
 	spin_lock(&lock);
 	for (i = 0; i < n_cpus; ++i)
-		n += snprintf(page + n, count - n, "%s%d",
-			      i == 0 ? "":" ", intf->cpu_to_q[i]);
+		seq_printf(seq, "%s%d", i == 0 ? "":" ", intf->cpu_to_q[i]);
 	spin_unlock(&lock);
-	n += snprintf(page + n, count - n, "\n");
-	*eof = 1;
-	return n;
+	seq_printf(seq, "\n");
+	return 0;
 }
+static int aff_proc_open_cpu2rxq(struct inode *inode, struct file *file)
+{
+	return single_open(file, aff_proc_read_cpu2rxq, PDE_DATA(inode));
+}
+static const struct file_operations aff_proc_fops_cpu2rxq = {
+	.owner		= THIS_MODULE,
+	.open		= aff_proc_open_cpu2rxq,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 
-static int aff_proc_read_filters(char *page, char **start, off_t off,
-				 int count, int *eof, void *data)
+static int aff_proc_read_filters(struct seq_file *seq, void *s)
 {
-	struct aff_interface *intf = data;
+	struct aff_interface *intf = seq->private;
 	struct aff_filter *f;
-	int i, n = 0;
-	*start = (char*)(unsigned long) 1;
 	spin_lock(&lock);
-	i = 0;
 	list_for_each_entry(f, &intf->filters, intf_filters_link) {
-		if (i++ == off) {
-			n += snprintf(page + n, count - n,
-				      "%s "NIPP_FMT" "NIPP_FMT" %d %d %d\n",
-				      f->protocol == IPPROTO_TCP ? "tcp":"udp",
-				      NIPP(f->daddr, f->dport),
-				      NIPP(f->saddr, f->sport),
-				      f->rq_cpu, f->rq_rxq, f->rxq);
-			break;
-		}
+		seq_printf(seq, 
+			   "%s "NIPP_FMT" "NIPP_FMT" %d %d %d\n",
+			   f->protocol == IPPROTO_TCP ? "tcp":"udp",
+			   NIPP(f->daddr, f->dport),
+			   NIPP(f->saddr, f->sport),
+			   f->rq_cpu, f->rq_rxq, f->rxq);
 	}
 	spin_unlock(&lock);
-	if (n == 0)
-		*eof = 1;
-	return n;
+	return 0;
 }
+static int aff_proc_open_filters(struct inode *inode, struct file *file)
+{
+	return single_open(file, aff_proc_read_filters, PDE_DATA(inode));
+}
+static const struct file_operations aff_proc_fops_filters = {
+	.owner		= THIS_MODULE,
+	.open		= aff_proc_open_filters,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 
 static struct aff_interface *__interface_find(int ifindex)
@@ -175,21 +240,16 @@
 
 static void interface_add_proc(struct aff_interface *intf,
 			       const char *name, void *data,
-			       int (*read_proc)(char *, char **, off_t, int, 
-						int *, void *))
+			       const struct file_operations *proc_fops)
 {
-	struct proc_dir_entry *pde;
-	if ((pde = create_proc_entry(name, 0444, intf->proc_dir))) {
-		pde->data = data;
-		pde->read_proc = read_proc;
-	}
+	proc_create_data(name, 0444, intf->proc_dir, proc_fops, data);
 }
 
 
 static void interface_add_proc_int(struct aff_interface *intf,
 				   const char *name, int *data)
 {
-	interface_add_proc(intf, name, data, aff_proc_read_int);
+	interface_add_proc(intf, name, data, &aff_proc_fops_int);
 }
 
 
@@ -200,9 +260,9 @@
 		interface_add_proc_int(intf, "ifindex", &intf->ifindex);
 		interface_add_proc_int(intf, "n_rxqs", &intf->n_rxqs);
 		interface_add_proc(intf, "cpu2rxq", intf,
-				   aff_proc_read_cpu2rxq);
+				   &aff_proc_fops_cpu2rxq);
 		interface_add_proc(intf, "filters", intf,
-				   aff_proc_read_filters);
+				   &aff_proc_fops_filters);
 	}
 }
 
@@ -560,9 +620,9 @@
 }
 
 
-static int aff_proc_write_new_interface(struct file *file,
-					const char __user *buffer,
-					unsigned long count, void *data)
+static ssize_t aff_proc_write_new_interface(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
 {
 	int max_cpus = num_possible_cpus();
 	int i, rc, ifindex, n_rxqs;
@@ -604,6 +664,10 @@
 fail1:
 	return rc;
 }
+static const struct file_operations aff_proc_fops_new_interface = {
+	.owner		= THIS_MODULE,
+	.write		= aff_proc_write_new_interface,
+};
 
 
 static int aff_proc_init(void)
@@ -615,18 +679,12 @@
 	if (aff_proc_root == NULL)
 		goto fail1;
 
-	pde = create_proc_entry("new_interface", 0644, aff_proc_root);
+	pde = proc_create("new_interface", 0644, aff_proc_root,
+			&aff_proc_fops_new_interface);
 	if (pde == NULL)
-		goto fail2;
-	pde->data = NULL;
-	pde->write_proc = aff_proc_write_new_interface;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
-	pde->owner = THIS_MODULE;
-#endif
+		goto fail1;
 	return 0;
 
-fail2:
-	remove_proc_entry("driver/sfc_affinity", NULL);
 fail1:
 	return rc;
 }
diff -ur openonload-201210-u2_orig/src/driver/linux_onload/linux_cplane.c openonload-201210-u2_patched/src/driver/linux_onload/linux_cplane.c
--- openonload-201210-u2_orig/src/driver/linux_onload/linux_cplane.c	2013-07-25 14:33:10.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_onload/linux_cplane.c	2013-09-27 10:08:52.000000000 +0100
@@ -77,6 +77,7 @@
 #include <linux/inetdevice.h>
 /* Compat just for RHEL4 clock_t_to_jiffies() */
 #include <linux/times.h>
+#include "../linux_resource/kernel_compat.h"
 
 
 
@@ -783,24 +784,17 @@
 }
 
 
-extern int 
-cicp_stat_read_proc(char *buf, char **start, off_t offset, int count,
-		    int *eof, void *caller_info)
-{   int len=0;
-    cicp_stat_t *statp = &(procfs_control_plane(caller_info)->stat);
+static int 
+cicp_stat_read_proc(struct seq_file *seq, void *s)
+{
+    cicp_stat_t *statp = &(procfs_control_plane(seq->private)->stat);
     ci_assert(statp);
 
-    (void)start;       /* unused */
-    (void)caller_info; /* unused */
 
-    if (offset != 0)
-	buf[0]='\0';
-    else
-    {
 #define CICP_READ_PROC_PRINT_CTR(counter) \
-  len += snprintf(buf+len, count-len, "%14s = %u\n", #counter, statp->counter)
+  seq_printf(seq, "%14s = %u\n", #counter, statp->counter)
 #define CICP_READ_PROC_PRINT_TIME(timer) \
-  len += snprintf(buf+len, count-len, "%17s = %u\n", #timer, statp->timer)
+  seq_printf(seq, "%17s = %u\n", #timer, statp->timer)
 	/* using snprintf instead of sprintf will fix bug1584 */
 
 	/* Dump the counters */
@@ -822,33 +816,31 @@
 	CICP_READ_PROC_PRINT_TIME(last_poll_bgn);
 	CICP_READ_PROC_PRINT_TIME(last_poll_end);
 	CICP_READ_PROC_PRINT_TIME(pkt_last_recv);
-	len += snprintf(buf+len, count-len, "%17s = %lu (%dHz)\n",
-			"Time Now", jiffies, HZ);
-    }    
-    return strlen(buf);
+	seq_printf(seq, "%17s = %lu (%dHz)\n", "Time Now", jiffies, HZ);
+    return 0;
 }
-
+static int cicp_stat_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, cicp_stat_read_proc, PDE_DATA(inode));
+}
+const struct file_operations cicp_stat_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicp_stat_open_proc,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 
 
 static int
-cicpos_hwport_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                   void *caller_info)
-{   cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
+cicpos_hwport_read(struct seq_file *seq, void *s)
+{   cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
     const cicp_hwport_kmib_t *hwportt = control_plane->hwport_table;
-    int len = 0;
 
-    (void)start;       /* unused */
-    (void)caller_info; /* unused */
-
-    if (offset != 0)
-	buf[0]='\0';
-    else
-    {
 	if (NULL == hwportt)
-	    len += snprintf(buf+len, bufsz-len,
-			    "hardware port table unallocated\n");
+	    seq_printf(seq, "hardware port table unallocated\n");
 	else
 	{   int n = 0;
 	    int nicid;
@@ -857,50 +849,43 @@
 	    {   const cicp_hwdev_row_t *port_row = &hwportt->nic[nicid];
 		const cicp_hwport_row_t *row = &port_row->port;
 
-		if (cicp_hwport_row_allocated(row) && len < bufsz)
+		if (cicp_hwport_row_allocated(row))
 		{   CICP_LOCK_BEGIN(control_plane)
 			/* better to use a read lock really */
-			len += snprintf(buf+len, bufsz-len,
-					"nic %02d: max mtu %d\n",
-					nicid, row->max_mtu);
+			seq_printf(seq, "nic %02d: max mtu %d\n",
+				   nicid, row->max_mtu);
 			CICP_LOCK_END
 			n++;
 		}
 	    }
 
-	    if (len < bufsz)
-		len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n",
-                                n, CI_HWPORT_ID_MAX+1);
+	    seq_printf(seq, "%d (of %d) allocated\n",
+                       n, CI_HWPORT_ID_MAX+1);
 	}
-    }
-    *eof = TRUE;
-    buf[bufsz-2]='\n'; /* end neatly even if we overran */
-    buf[bufsz-1]='\0';
-    return strlen(buf);
+    return 0;
 }
-
-
+static int cicpos_hwport_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, cicpos_hwport_read, PDE_DATA(inode));
+}
+static const struct file_operations cicpos_hwport_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_hwport_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 
 static int
-cicpos_llap_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                 void *caller_info)
-{   cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
+cicpos_llap_read(struct seq_file *seq, void *s)
+{   cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
 
     const cicp_llap_kmib_t *llapt = control_plane->llap_table;
-    int len = 0;
-	
-    (void)start;       /* unused */
-    (void)caller_info; /* unused */
 
-    if (offset != 0)
-	buf[0]='\0';
-    else
-    {
 	if (NULL == llapt)
-	    len += snprintf(buf+len, bufsz-len,
-			    "link layer access point table unallocated\n");
+	    seq_printf(seq, "link layer access point table unallocated\n");
 	else
 	{   cicp_llap_rowid_t llap_index;
 	    int n = 0;
@@ -910,240 +895,185 @@
 		 llap_index++)
 	    {   const cicp_llap_row_t *row = &llapt->llap[llap_index];
 
-		if (cicp_llap_row_allocated(row) && len < bufsz)
+		if (cicp_llap_row_allocated(row))
 		{   CICP_LOCK_BEGIN(control_plane)
 			/* better to use a read lock really */
 
-			len += snprintf(buf+len, bufsz-len,
-					"%02d: llap %02d %4s %4s port ",
-					llap_index, row->ifindex, row->name,
-					row->up? "UP ": "DOWN");
+			seq_printf(seq, "%02d: llap %02d %4s %4s port ",
+				   llap_index, row->ifindex, row->name,
+				   row->up? "UP ": "DOWN");
                         if (cicp_llap_row_hasnic(&control_plane->user, row))
-			{   len += 
-                            snprintf(buf+len, bufsz-len, "%1d ", row->hwport);
-			    len += snprintf(buf+len, bufsz-len,
-					    "mac "CI_MAC_PRINTF_FORMAT
-					    " mtu %d",
-					    CI_MAC_PRINTF_ARGS(&row->mac),
-					    row->mtu);
+			{
+                            seq_printf(seq, "%1d ", row->hwport);
+			    seq_printf(seq, "mac "CI_MAC_PRINTF_FORMAT
+				       " mtu %d",
+				       CI_MAC_PRINTF_ARGS(&row->mac),
+				       row->mtu);
 			} else
-			{   len += snprintf(buf+len, bufsz-len,
-					    "X ");
+			{   seq_printf(seq, "X ");
 			}
 			if (row->encapsulation.type & CICP_LLAP_TYPE_VLAN) {
-			    len += snprintf(buf+len, bufsz-len, " VLAN %d",
-					    row->encapsulation.vlan_id);
+			    seq_printf(seq, " VLAN %d",
+				       row->encapsulation.vlan_id);
 			}
 			if (row->encapsulation.type & CICP_LLAP_TYPE_BOND) {
-			    len += snprintf(buf+len, bufsz-len, " BOND HW%d ROW%d",
-					    row->hwport, row->bond_rowid);
+			    seq_printf(seq, " BOND HW%d ROW%d",
+				       row->hwport, row->bond_rowid);
 			}
 			if (row->encapsulation.type & 
 			    CICP_LLAP_TYPE_USES_HASH) {
-			    len += snprintf(buf+len, bufsz-len, " HASH");
+			    seq_printf(seq, " HASH");
 			    if (row->encapsulation.type & 
 				CICP_LLAP_TYPE_XMIT_HASH_LAYER4) {
-				len += snprintf(buf+len, bufsz-len, "-L4");
+				seq_printf(seq, "-L4");
 			    }
 			}
 
-			len += snprintf(buf+len, bufsz-len, "\n");
+			seq_printf(seq, "\n");
 
 		    CICP_LOCK_END
 		    n++;
 		}
 	    }
 
-	    if (len < bufsz)
-		len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n",
-                                n, llapt->rows_max);
+	    seq_printf(seq, "%d (of %d) allocated\n", n, llapt->rows_max);
 	}
-    }
-    *eof = TRUE;
-    buf[bufsz-2]='\n'; /* end neatly even if we overran */
-    buf[bufsz-1]='\0';
-    return strlen(buf);
+    return 0;
+}
+static int cicpos_llap_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, cicpos_llap_read, PDE_DATA(inode));
 }
+static const struct file_operations cicpos_llap_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_llap_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
-/*
- * Attention: MAC_STR_LENGTH should be more than total length
- *            returned by snprintfs.
- */
+static void *cicpos_mac_read_start(struct seq_file *seq, loff_t *pos)
+{
+    cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
+    const cicp_mac_mib_t *umact = control_plane->user.mac_utable;
+    if (umact == NULL)
+      return NULL;
+    return (*pos <= cicp_mac_mib_rows(umact)) ? pos : NULL;
+}
+static void *cicpos_mac_read_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+    (*pos)++;
+    return cicpos_mac_read_start(seq, pos);
+}
+static void cicpos_mac_read_stop(struct seq_file *seq, void *s)
+{
+}
 static int
-cicpos_mac_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                void *caller_info)
+cicpos_mac_read(struct seq_file *seq, void *s)
 {
-    cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
+    cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
     const cicp_mac_mib_t *umact = control_plane->user.mac_utable;
     const cicp_mac_kmib_t *kmact = control_plane->mac_table;
+    cicp_mac_rowid_t mac_index = *(loff_t *)s;
 
-    /*const cicp_mac_kmib_t *kmact = control_plane->mac_table;*/
-
-    int len = 0;
-    int entries;
-    int str_end;
-    int n = 0;
-    off_t offset_orig = offset;
-
-    cicp_mac_rowid_t mac_index = 0;
-
-    (void)caller_info; /* unused */
-
-    memset(buf, ' ', bufsz);
-
-#ifdef MAC_STR_LENGTH
-#undef MAC_STR_LENGTH
-#endif
-#define MAC_STR_LENGTH    160
-
-#ifdef MAC_STR_LAST_POS
-#undef MAC_STR_LAST_POS
-#endif
-#define MAC_STR_LAST_POS  (MAC_STR_LENGTH - 1)
-
-    entries = bufsz / MAC_STR_LENGTH;
-
-    if (entries == 0)
+    if (NULL == umact)
     {
-        /* Provided bufsz is insufficient to retrieve whole mac entry */
+        seq_printf(seq, "user address resolution table unallocated\n");
     }
-    else if (NULL == umact)
+    else if (mac_index == cicp_mac_mib_rows(umact))
     {
-        if (offset_orig == 0)
-            len += snprintf(buf+len, bufsz-len,
-                            "user address resolution table unallocated\n");
-        *eof = TRUE;
-    }
-    else
-    {
-        for (mac_index = 0;
-             mac_index < cicp_mac_mib_rows(umact);
+        int n = 0;
+        for (mac_index = 0; mac_index < cicp_mac_mib_rows(umact);
              mac_index++)
-        {
-            const cicp_mac_row_t *row = &umact->ipmac[mac_index];
-            const cicp_mac_kernrow_t *krow = &kmact->entry[mac_index];
-            const cicpos_mac_row_t *sync = &krow->sync;
-
-            if (cicp_mac_row_allocated(row) && len < bufsz)
-            {
-                if (offset >= MAC_STR_LENGTH)
-                {
-                    offset -= MAC_STR_LENGTH;
-                    continue;
-                }
-
-                CICP_LOCK_BEGIN(control_plane)
-		    /* better to use a read lock really */
-
-                    str_end = len + MAC_STR_LAST_POS;
-                    /* user-visible args */
-                    len += snprintf(buf+len, bufsz-len,
-                                    "#%04x: llap %02d %4s"
-                                    " ip "CI_IP_PRINTF_FORMAT
-                                    " mac "CI_MAC_PRINTF_FORMAT
-                                    " on %3d%s%s",
-                                     mac_index, row->ifindex,
-				    _cicp_llap_get_name(control_plane,
-							row->ifindex),
-                                     CI_IP_PRINTF_ARGS(&row->ip_addr),
-                                     CI_MAC_PRINTF_ARGS(&row->mac_addr),
-                                     cicp_mac_row_usecount(row),
-                                     cicp_mac_row_enter_requested(row)?
-                                     " !service!": "",
-                row->need_update == CICP_MAC_ROW_NEED_UPDATE_STALE ?
-                " STALE" :
-                row->need_update == CICP_MAC_ROW_NEED_UPDATE_SOON ?
-                " almost-STALE" : "");
-                    /* O/S synch args */
-                    len += snprintf(buf+len, bufsz-len,
-                                    " [u %08x up %08x ref %d "
-                                    "%s%s%s%s%s%s%s%s%s%02X "
-                                    "%03d %s%s%s]",
-                                    sync->os.used, sync->os.updated,
-                                    sync->os.refcnt,
-                                    0 == sync->os.state? "NONE ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_INCOMPLETE)?
-                                          "INCOMPLETE ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_REACHABLE)?
-                                          "REACHABLE ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_STALE)?
-                                          "STALE ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_DELAY)?
-                                          "DELAY ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_PROBE)?
-                                          "PROBE ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_FAILED)?
-                                          "FAILED ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_NOARP)?
-                                          "NOARP ":"",
-                                    0 != (sync->os.state &
-                                          CICPOS_IPMAC_PERMANENT)?
-                                          "PERMANENT ":"",
-                                    sync->os.flags, sync->os.family,
-                                    0 != sync->source_sync? "S": "s",
-                                    0 != sync->source_prot? "P": "p",
-                                    0 != sync->recent_sync? "R": "r");
-                    len += snprintf(buf+len, bufsz-len, " v%d rc %d",
-                                    row->version, (ci_int16)row->rc);
-                    *(buf + len) = ' ';
-                    len = str_end;
-                    *(buf + len) = '\n';
-                    len++;
-
-                CICP_LOCK_END
-
+            if (cicp_mac_row_allocated(&umact->ipmac[mac_index]))
                 n++;
-                entries--;
-                if (entries == 0)
-                    break;
-            }
-        }
-
-        if ((n == 0) && (offset_orig == 0) && (umact != NULL))
-            len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n", 
-                            n, cicp_mac_mib_rows(umact));
-
-        *start = (char *)((ci_ptr_arith_t)len);
+        seq_printf(seq, "%d (of %d) allocated\n",
+                   n, cicp_mac_mib_rows(umact));
     }
+    else if (cicp_mac_row_allocated(&umact->ipmac[mac_index]))
+    {
+        const cicp_mac_row_t *row = &umact->ipmac[mac_index];
+        const cicp_mac_kernrow_t *krow = &kmact->entry[mac_index];
+        const cicpos_mac_row_t *sync = &krow->sync;
+
+        CICP_LOCK_BEGIN(control_plane)
+        /* better to use a read lock really */
+
+        /* user-visible args */
+        seq_printf(seq, "#%04x: llap %02d %4s ip "CI_IP_PRINTF_FORMAT
+                   " mac "CI_MAC_PRINTF_FORMAT" on %3d%s%s",
+                   mac_index, row->ifindex,
+                   _cicp_llap_get_name(control_plane, row->ifindex),
+                   CI_IP_PRINTF_ARGS(&row->ip_addr),
+                   CI_MAC_PRINTF_ARGS(&row->mac_addr),
+                   cicp_mac_row_usecount(row),
+                   cicp_mac_row_enter_requested(row) ? " !service!": "",
+                   row->need_update == CICP_MAC_ROW_NEED_UPDATE_STALE ?
+                        " STALE" :
+                        row->need_update == CICP_MAC_ROW_NEED_UPDATE_SOON ?
+                        " almost-STALE" : "");
+        /* O/S synch args */
+        seq_printf(seq, " [u %08x up %08x ref %d %s%s%s%s%s%s%s%s%s%02X "
+                   "%03d %s%s%s]",
+                   sync->os.used, sync->os.updated, sync->os.refcnt,
+                   0 == sync->os.state? "NONE ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_INCOMPLETE)?
+                            "INCOMPLETE ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_REACHABLE)?
+                            "REACHABLE ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_STALE) ? "STALE ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_DELAY) ? "DELAY ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_PROBE) ? "PROBE ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_FAILED) ?
+                            "FAILED ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_NOARP)?  "NOARP ":"",
+                   0 != (sync->os.state & CICPOS_IPMAC_PERMANENT)?
+                            "PERMANENT ":"",
+                   sync->os.flags, sync->os.family,
+                   0 != sync->source_sync? "S": "s",
+                   0 != sync->source_prot? "P": "p",
+                   0 != sync->recent_sync? "R": "r");
+        seq_printf(seq, " v%d rc %d\n", row->version, (ci_int16)row->rc);
 
-    if (mac_index == cicp_mac_mib_rows(umact))
-        *eof = TRUE;
-
-    return len;
+        CICP_LOCK_END
+    }
 
-#undef MAC_STR_LENGTH
-#undef MAC_STR_LAST_POS
+    return 0;
+}
+static struct seq_operations cicpos_mac_seq_ops = {
+    .start = cicpos_mac_read_start,
+    .next  = cicpos_mac_read_next,
+    .stop  = cicpos_mac_read_stop,
+    .show  = cicpos_mac_read,
+};
+static int cicpos_mac_open(struct inode *inode, struct file *file)
+{
+    int rc;
+    rc = seq_open(file, &cicpos_mac_seq_ops);
+    if (rc != 0)
+        ((struct seq_file *)file->private_data)->private = PDE_DATA(inode);
+    return rc;
 }
+static const struct file_operations cicpos_mac_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_mac_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
+};
 
 
 
 
 
 static int
-cicpos_ipif_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                 void *caller_info)
-{   cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
+cicpos_ipif_read(struct seq_file *seq, void *s)
+{   cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
     const cicp_ipif_kmib_t *ipift = control_plane->ipif_table;
-    int len = 0;
-	
-    (void)start;       /* unused */
-    (void)caller_info; /* unused */
     
-    if (offset != 0)
-	buf[0]='\0';
-    else
-    {
 	if (NULL == ipift)
-	    len += snprintf(buf+len, bufsz-len,
-			    "IP interface table unallocated\n");
+	    seq_printf(seq, "IP interface table unallocated\n");
 	else
 	{   cicp_ipif_rowid_t ipif_index;
 	    int n = 0;
@@ -1153,11 +1083,10 @@
 		 ipif_index++)
 	    {   const cicp_ipif_row_t *row = &ipift->ipif[ipif_index];
 
-		if (cicp_ipif_row_allocated(row) && len < bufsz)
+		if (cicp_ipif_row_allocated(row))
 		{   CICP_LOCK_BEGIN(control_plane)
 			/* better to use a read lock really */
-			len += snprintf(buf+len, bufsz-len,
-					"%02d: llap %02d %4s "
+			seq_printf(seq, "%02d: llap %02d %4s "
 					CI_IP_PRINTF_FORMAT
 					"/%d\t bcast "CI_IP_PRINTF_FORMAT
 					" scope %s\n",
@@ -1175,46 +1104,44 @@
 		}
 	    }
 
-	    if (len < bufsz)
-		len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n",
-                                n, ipift->rows_max);
+	    seq_printf(seq, "%d (of %d) allocated\n", n, ipift->rows_max);
 	}
-    }
-    *eof = TRUE;
-    buf[bufsz-2]='\n'; /* end neatly even if we overran */
-    buf[bufsz-1]='\0';
-    return strlen(buf);
+    return 0;
+}
+static int cicpos_ipif_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, cicpos_ipif_read, PDE_DATA(inode));
 }
+static const struct file_operations cicpos_ipif_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_ipif_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 static int 
-cicpos_bond_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                 void *caller_info)
+cicpos_bond_read(struct seq_file *seq, void *s)
 {
-  cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
+  cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
   const cicp_bondinfo_t *bondt;
-  int len = 0;
   int n = 0;
   int i;
   
   bondt = control_plane->user.bondinfo_utable;
   
-  memset(buf, ' ', bufsz);
 
-  if( offset != 0 )
-    buf[0]='\0';
-  else {
     if( bondt == NULL )
-      len += snprintf(buf+len, bufsz-len, "bond table unallocated\n");
+      seq_printf(seq, "bond table unallocated\n");
     else {
       for( i = 0; i < bondt->rows_max; i++ ) {
         const cicp_bond_row_t *row = &bondt->bond[i];
-        if( cicp_bond_row_allocated(row) && len < bufsz) {
+        if( cicp_bond_row_allocated(row) ) {
           CICP_LOCK_BEGIN(control_plane);
 
           if( row->type == CICP_BOND_ROW_TYPE_MASTER ) 
-            len += snprintf(buf+len, bufsz-len, 
-                            "Row %d: MST if %d, next %d, "
+            seq_printf(seq, "Row %d: MST if %d, next %d, "
                             "mode %d, hash %d, slaves %d, actv_slaves %d, "
                             "actv_hwport %d\n",
                             i, row->ifid, row->next, 
@@ -1223,188 +1150,132 @@
                             row->master.n_active_slaves,
                             row->master.active_hwport);
           else if( row->type == CICP_BOND_ROW_TYPE_SLAVE )
-            len += snprintf(buf+len, bufsz-len,
-                            "Row %d: SLV if %d, next %d, "
+            seq_printf(seq, "Row %d: SLV if %d, next %d, "
                             "hwport %d, flags %d (%s)\n",
                             i, row->ifid, row->next, row->slave.hwport,
                             row->slave.flags, 
                             row->slave.flags & CICP_BOND_ROW_FLAG_ACTIVE ?
                             "Active" : "Inactive");
           else
-            len += snprintf(buf+len, bufsz-len, "Bond row %d: BAD type %d\n", 
+            seq_printf(seq, "Bond row %d: BAD type %d\n", 
                             i, row->type);
           CICP_LOCK_END;
 
           ++n;
         }
       }
-      if (len < bufsz)
-        len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n", 
-                        n, bondt->rows_max);
+      seq_printf(seq, "%d (of %d) allocated\n", n, bondt->rows_max);
     }
-  }
 
-  *eof = TRUE;
-  buf[bufsz-2]='\n'; /* end neatly even if we overran */
-  buf[bufsz-1]='\0';
-  return strlen(buf);
+  return 0;
 }
+static int cicpos_bond_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, cicpos_bond_read, PDE_DATA(inode));
+}
+static const struct file_operations cicpos_bond_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_bond_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 
+static void *cicpos_fwd_read_start(struct seq_file *seq, loff_t *pos)
+{
+    cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
+    const cicp_fwdinfo_t *fwdt = control_plane->user.fwdinfo_utable;
+    if (fwdt == NULL)
+      return NULL;
+    return (*pos <= fwdt->rows_max) ? pos : NULL;
+}
+static void *cicpos_fwd_read_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+    (*pos)++;
+    return cicpos_fwd_read_start(seq, pos);
+}
+static void cicpos_fwd_read_stop(struct seq_file *seq, void *s)
+{
+}
 /*
- * FWD info retrieves series of blocks of an equal length.
- * Block consists of 3 strings. The strings in the block have the equal
- * length.
- * ATTENTION: The length of string returned by appropriate snprintf
- *            should not exceed FWD_STR_LENGTH.
+ * FWD info retrieves series of blocks.  Block consists of 3 strings.
  */
 static int
-cicpos_fwd_read(char *buf, char **start, off_t offset, int bufsz, int *eof,
-                void *caller_info)
-{   cicp_mibs_kern_t *control_plane = procfs_control_plane(caller_info);
-    const cicp_fwdinfo_t *fwdt;
-    int len = 0;
-    int str_end = 0;
-    int entries;
-    int n = 0;
-    off_t offset_orig = offset;
-    cicp_fwd_rowid_t fwd_index = 0;
-
-    (void)caller_info; /* unused */
-
-    fwdt = control_plane->user.fwdinfo_utable;
+cicpos_fwd_read(struct seq_file *seq, void *s)
+{   cicp_mibs_kern_t *control_plane = procfs_control_plane(seq->private);
+    const cicp_fwdinfo_t *fwdt = control_plane->user.fwdinfo_utable;
+    cicp_fwd_rowid_t fwd_index = *(loff_t *)s;
 
-    memset(buf, ' ', bufsz);
-
-#ifdef FWD_TAB
-#undef FWD_TAB
-#endif
-#define FWD_TAB          8
-
-#ifdef FWD_STR_LENGTH
-#undef FWD_STR_LENGTH
-#endif
-#define FWD_STR_LENGTH   80
-
-#ifdef FWD_STR_LAST_POS
-#undef FWD_STR_LAST_POS
-#endif
-#define FWD_STR_LAST_POS  (FWD_STR_LENGTH - 1)
-
-#ifdef FWD_ENTRY_LENGTH
-#undef FWD_ENTRY_LENGTH
-#endif
-#define FWD_ENTRY_LENGTH  (FWD_STR_LENGTH * 3)
-
-    entries = bufsz / FWD_ENTRY_LENGTH;
-
-    if (entries == 0)
+    if (NULL == fwdt)
     {
-        /* Provided bufsz is insufficient to retrive whole fwd entry */
+        seq_printf(seq, "user forwarding information unallocated\n");
     }
-    else if (NULL == fwdt)
-    {
-        if (offset_orig == 0)
-        len += snprintf(buf+len, bufsz-len,
-                        "user forwarding information unallocated\n");
-        *eof = TRUE;
+    else if (fwd_index == fwdt->rows_max) {
+      int n = 0;
+      for (fwd_index = 0; fwd_index < fwdt->rows_max; fwd_index++)
+          if (cicp_fwd_row_allocated(&fwdt->path[fwd_index]))
+              n++;
+      seq_printf(seq, "%d (of %d) allocated\n", n, fwdt->rows_max);
     }
-    else
+    else if (cicp_fwd_row_allocated(&fwdt->path[fwd_index]))
     {
-        for (fwd_index = 0; fwd_index < fwdt->rows_max; fwd_index++)
-        {
-            const cicp_fwd_row_t *row = &fwdt->path[fwd_index];
-
-            if (cicp_fwd_row_allocated(row) && len < bufsz)
-            {
-                if (offset >= FWD_ENTRY_LENGTH)
-                {
-                    offset -= FWD_ENTRY_LENGTH;
-                    continue;
-                }
-
-                /* better to use a read lock really */
-                CICP_LOCK_BEGIN(control_plane)
-                    /* first string */
-                    str_end = len + FWD_STR_LAST_POS;
-                    len += snprintf(buf+len, bufsz-len,
-                                    CI_IP_PRINTF_FORMAT"/%u -> "
-                                    CI_IP_PRINTF_FORMAT
-                                    " llap %d %4s port ",
-                                    CI_IP_PRINTF_ARGS(&row->destnet_ip),
-                                    row->destnet_ipset,
-                                    CI_IP_PRINTF_ARGS(&row->first_hop),
-                                    row->dest_ifindex,
-                                    _cicp_llap_get_name(control_plane,
-							row->dest_ifindex));
-                    if (cicp_fwd_row_hasnic(&control_plane->user, row))
-                        len += 
-                          snprintf(buf+len, bufsz-len,
-                                   "%1d encap " CICP_ENCAP_NAME_FMT,
-                                   row->hwport,
-                                   cicp_encap_name(row->encap.type));
-                    else
-                        len += snprintf(buf+len, bufsz-len,
-                                        "X");
-                    *(buf + len) = ' ';
-                    len = str_end;
-                    *(buf + len) = '\n';
-                    len++;
-                    /* second string */
-                    str_end = len + FWD_STR_LAST_POS;
-                    len += FWD_TAB;
-                    len += snprintf(buf+len, bufsz-len,
-                                    "dst "CI_IP_PRINTF_FORMAT
-                                    "/%d bcast "
-                                    CI_IP_PRINTF_FORMAT" mtu %d"
-                                    " tos %d metric %d",
-                                    CI_IP_PRINTF_ARGS(&row->net_ip),
-                                    row->net_ipset,
-                                    CI_IP_PRINTF_ARGS(&row->net_bcast),
-                                    row->mtu,
-                                    row->tos, row->metric);
-                    *(buf + len) = ' ';
-                    len = str_end;
-                    *(buf + len) = '\n';
-                    len++;
-                    /* third string */
-                    str_end = len + FWD_STR_LAST_POS;
-                    len += FWD_TAB;
-                    len += snprintf(buf+len, bufsz-len,
-                                    "src ip "CI_IP_PRINTF_FORMAT
-                                    " mac "CI_MAC_PRINTF_FORMAT,
-                                    CI_IP_PRINTF_ARGS(&row->pref_source),
-                                    CI_MAC_PRINTF_ARGS(&row->
-                                                           pref_src_mac));
-                    *(buf + len) = ' ';
-                    len = str_end;
-                    *(buf + len) = '\n';
-                    len++;
-                CICP_LOCK_END
-                n++;
-                entries--;
-                if (entries == 0)
-                    break;
-            }
-        }
-
-	*start = (char *)((ci_ptr_arith_t)len);
-    }
-
-    if (fwd_index == fwdt->rows_max) {
-        if( fwdt != NULL && len < bufsz )
-          len += snprintf(buf+len, bufsz-len, "%d (of %d) allocated\n", 
-                          n, fwdt->rows_max);
-        *eof = TRUE;
+        const cicp_fwd_row_t *row = &fwdt->path[fwd_index];
+        /* better to use a read lock really */
+        CICP_LOCK_BEGIN(control_plane)
+        /* first string */
+        seq_printf(seq, CI_IP_PRINTF_FORMAT"/%u -> "CI_IP_PRINTF_FORMAT
+                   " llap %d %4s port ",
+                   CI_IP_PRINTF_ARGS(&row->destnet_ip),
+                   row->destnet_ipset,
+                   CI_IP_PRINTF_ARGS(&row->first_hop),
+                   row->dest_ifindex,
+                   _cicp_llap_get_name(control_plane, row->dest_ifindex));
+        if (cicp_fwd_row_hasnic(&control_plane->user, row))
+            seq_printf(seq, "%1d encap " CICP_ENCAP_NAME_FMT,
+                       row->hwport, cicp_encap_name(row->encap.type));
+        else
+            seq_printf(seq, "X");
+        seq_printf(seq, "\n");
+        /* second string */
+        seq_printf(seq, "\tdst "CI_IP_PRINTF_FORMAT"/%d "
+                   "bcast "CI_IP_PRINTF_FORMAT" mtu %d tos %d metric %d",
+                   CI_IP_PRINTF_ARGS(&row->net_ip), row->net_ipset,
+                   CI_IP_PRINTF_ARGS(&row->net_bcast),
+                   row->mtu, row->tos, row->metric);
+        seq_printf(seq, "\n");
+        /* third string */
+        seq_printf(seq, "\tsrc ip "CI_IP_PRINTF_FORMAT
+                   " mac "CI_MAC_PRINTF_FORMAT"\n",
+                   CI_IP_PRINTF_ARGS(&row->pref_source),
+                   CI_MAC_PRINTF_ARGS(&row->pref_src_mac));
+        CICP_LOCK_END
     }
 
-    return len;
-#undef FWD_TAB
-#undef FWD_STR_LENGTH
-#undef FWD_STR_LAST_POS
-#undef FWD_ENTRY_LENGTH
+    return 0;
 }
+static struct seq_operations cicpos_fwd_seq_ops = {
+    .start = cicpos_fwd_read_start,
+    .next  = cicpos_fwd_read_next,
+    .stop  = cicpos_fwd_read_stop,
+    .show  = cicpos_fwd_read,
+};
+static int cicpos_fwd_open(struct inode *inode, struct file *file)
+{
+    int rc;
+    rc = seq_open(file, &cicpos_fwd_seq_ops);
+    if (rc != 0)
+        ((struct seq_file *)file->private_data)->private = PDE_DATA(inode);
+    return rc;
+}
+static const struct file_operations cicpos_fwd_fops = {
+    .owner   = THIS_MODULE,
+    .open    = cicpos_fwd_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
+};
 
 
 static void
@@ -1422,18 +1293,18 @@
     {
 	ci_assert(NULL != oo_proc_root);
 
-	create_proc_read_entry(CICPOS_PROCFS_FILE_HWPORT, 0, oo_proc_root,
-			       &cicpos_hwport_read, caller_info);
-	create_proc_read_entry(CICPOS_PROCFS_FILE_LLAP, 0, oo_proc_root,
-			       &cicpos_llap_read, caller_info);
-	create_proc_read_entry(CICPOS_PROCFS_FILE_MAC, 0, oo_proc_root,
-			       &cicpos_mac_read, caller_info);
-	create_proc_read_entry(CICPOS_PROCFS_FILE_IPIF, 0, oo_proc_root,
-			       &cicpos_ipif_read,  caller_info);
-	create_proc_read_entry(CICPOS_PROCFS_FILE_FWDINFO, 0, oo_proc_root,
-			       &cicpos_fwd_read,  caller_info);
-	create_proc_read_entry(CICPOS_PROCFS_FILE_BONDINFO, 0, oo_proc_root,
-			       &cicpos_bond_read,  caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_HWPORT, 0, oo_proc_root,
+			 &cicpos_hwport_fops, caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_LLAP, 0, oo_proc_root,
+			 &cicpos_llap_fops, caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_MAC, 0, oo_proc_root,
+			 &cicpos_mac_fops, caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_IPIF, 0, oo_proc_root,
+			 &cicpos_ipif_fops,  caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_FWDINFO, 0, oo_proc_root,
+			 &cicpos_fwd_fops,  caller_info);
+	proc_create_data(CICPOS_PROCFS_FILE_BONDINFO, 0, oo_proc_root,
+			 &cicpos_bond_fops,  caller_info);
     }
 }
 
diff -ur openonload-201210-u2_orig/src/driver/linux_onload/linux_stats.c openonload-201210-u2_patched/src/driver/linux_onload/linux_stats.c
--- openonload-201210-u2_orig/src/driver/linux_onload/linux_stats.c	2013-07-25 14:33:10.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_onload/linux_stats.c	2013-09-27 10:08:52.000000000 +0100
@@ -59,6 +59,7 @@
 #include <net/udp.h>
 #include <linux/proc_fs.h>
 #include <linux/module.h>
+#include "../linux_resource/kernel_compat.h"
 
 
 
@@ -83,20 +84,9 @@
  *
  *--------------------------------------------------------------------*/
 
-
-static int
-efab_version_read_proc(char* buf, char** start, off_t offset, int count, 
-                       int* eof, void* data);
-static int 
-efabcfg_raw_read_proc(char *buf, char **start, off_t offset, int count, 
-                      int *eof, void *data);
-static int 
-efab_workq_read_proc(char *buf, char **start, off_t offset, int count, 
-		     int *eof, void *data);
-static int
-efab_dlfilters_read_proc(char* buf, char** start, off_t offset, int count, 
-                         int* eof, void* data);
-
+static const struct file_operations efab_workq_fops;
+static const struct file_operations efab_version_fops;
+static const struct file_operations efab_dlfilters_fops;
 
 /*--------------------------------------------------------------------
  *
@@ -106,16 +96,14 @@
 
 /* Entries under /proc/drivers/sfc */
 typedef struct ci_proc_efab_entry_s {
-  char        *name;             /**< Entry name */
-  read_proc_t *read_proc;        /**< Entry read_proc handler */
+  char                          *name;  /**< Entry name */
+  const struct file_operations  *fops;  /**< Proc file operations */
 } ci_proc_efab_entry_t;
 static ci_proc_efab_entry_t ci_proc_efab_table[] = {
-    {"cplane",         cicp_stat_read_proc}, 
-    {"onloadcfg_raw",  efabcfg_raw_read_proc}, 
-    {"workqueue",    efab_workq_read_proc},
-//    {"efabcfg_opts", efabcfg_opts_read_proc}, 
-    {"version",      efab_version_read_proc},
-    {"dlfilters",    efab_dlfilters_read_proc},
+    {"cplane",        &cicp_stat_fops}, 
+    {"workqueue",     &efab_workq_fops},
+    {"version",       &efab_version_fops},
+    {"dlfilters",     &efab_dlfilters_fops},
 };
 
 #define CI_PROC_EFAB_TABLE_SIZE \
@@ -142,94 +130,45 @@
 
 /****************************************************************************
  *
- * /proc/drivers/onload/onloadcfg_raw
- *
- ****************************************************************************/
-
-static int 
-efabcfg_raw_read_proc(char *buf, char **start, off_t offset, int count, 
-                      int *eof, void *data)
-{
-  ci_cfg_hdr_t *hdr;
-  int how_much, rc;
-
-  while (ci_cfg_rd_trylock() != 0) {
-    set_current_state(TASK_INTERRUPTIBLE);
-    schedule_timeout(0);
-  }
-  
-  hdr = ci_cfg_get();
- 
-  /* do we have a database installed? */
-  if (hdr == 0) {
-    rc = -ENODATA;
-    goto error;
-  }
-
-  /* have we reached or exceeded the end? */
-  if (offset >= hdr->len) {
-    rc = -EINVAL;
-    goto error;
-  }
-
-  /* number of bytes to copy */
-  how_much = CI_MIN(count, hdr->len - offset);
-  ci_assert_ge(how_much, 0);
-
-  /* copy the data */
-  memcpy(buf, (char*)hdr + offset, how_much);
-
-  ci_cfg_rd_unlock();
-
-  return how_much;
-
-error:
-  ci_cfg_rd_unlock();
-  return rc;
-}
-
-
-
-
-/****************************************************************************
- *
  * /proc/drivers/onload/workqueue
  *
  ****************************************************************************/
 
-#define PROC_PRINTF(fmt, ...)					\
-  if( count - len > 0 )						\
-    len += snprintf(buf+len, count-len, (fmt), __VA_ARGS__)
-#define EFAB_WORKQ_READ_PROC_PRINT(v)			\
-  PROC_PRINTF("%14s = %u\n", #v, wqueue->stats.v)
-#define PROC_PUT(str)					\
-  if( count - len > 0 )					\
-    len += snprintf(buf+len, count-len, "%s", (str))
-
 static int 
-efab_workq_read_proc(char *buf, char **start, off_t offset, int count, 
-		     int *eof, void *data)
+efab_workq_read_proc(struct seq_file *seq, void *s)
 {
-  int len = 0;
-#ifndef __USE_LINUX_WORKQUEUE
   ci_irqlock_state_t lock_flags;
   ci_workqueue_t *wqueue;
   wqueue = &CI_GLOBAL_WORKQUEUE;
   ci_irqlock_lock(&wqueue->lock, &lock_flags);
   if (wqueue->state == CI_WQ_ALIVE) {
+#define EFAB_WORKQ_READ_PROC_PRINT(v)			\
+    seq_printf(seq, "%14s = %u\n", #v, wqueue->stats.v)
       EFAB_WORKQ_READ_PROC_PRINT(working);
       EFAB_WORKQ_READ_PROC_PRINT(iter);
       EFAB_WORKQ_READ_PROC_PRINT(backlog);
       EFAB_WORKQ_READ_PROC_PRINT(started);
+#undef EFAB_WORKQ_READ_PROC_PRINT
   }
   else {	
-    PROC_PUT("The workqueue is not running.\n");
+    seq_printf(seq, "The workqueue is not running.\n");
   }
   ci_irqlock_unlock(&wqueue->lock, &lock_flags);
-#endif
 
-  return count ? strlen(buf) : 0;
+  return 0;
+}
+
+static int efab_workq_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, efab_workq_read_proc, 0);
 }
+static const struct file_operations efab_workq_fops = {
+    .owner   = THIS_MODULE,
+    .open    = efab_workq_open_proc,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 /****************************************************************************
@@ -324,15 +263,24 @@
  ****************************************************************************/
 
 static int 
-efab_version_read_proc(char* buf, char** start, off_t offset, int count, 
-                       int* eof, void* data)
+efab_version_read_proc(struct seq_file *seq, void *s)
+{
+  seq_printf(seq, "onload_product: %s\n", ONLOAD_PRODUCT);
+  seq_printf(seq, "onload_version: %s\n", ONLOAD_VERSION);
+  seq_printf(seq, "uk_intf_ver: %s\n", oo_uk_intf_ver);
+  return 0;
+}
+static int efab_version_open_proc(struct inode *inode, struct file *file)
 {
-  int len = 0; 
-  PROC_PRINTF("onload_product: %s\n", ONLOAD_PRODUCT);
-  PROC_PRINTF("onload_version: %s\n", ONLOAD_VERSION);
-  PROC_PRINTF("uk_intf_ver: %s\n", oo_uk_intf_ver);
-  return count ? strlen(buf) : 0;
+    return single_open(file, efab_version_read_proc, 0);
 }
+static const struct file_operations efab_version_fops = {
+    .owner   = THIS_MODULE,
+    .open    = efab_version_open_proc,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 /****************************************************************************
@@ -342,28 +290,37 @@
  ****************************************************************************/
 
 static int 
-efab_dlfilters_read_proc(char* buf, char** start, off_t offset, int count, 
-                         int* eof, void* data)
+efab_dlfilters_read_proc(struct seq_file *seq, void *s)
 {
-  int len = 0; 
   int no_empty, no_tomb, no_used;
 
   efx_dlfilter_count_stats(efab_tcp_driver.dlfilter,
                            &no_empty, &no_tomb, &no_used);
-  PROC_PRINTF("dlfilters: empty=%d, tomb=%d, used=%d\n",
-              no_empty, no_tomb, no_used);
-  return count ? strlen(buf) : 0;
+  seq_printf(seq, "dlfilters: empty=%d, tomb=%d, used=%d\n",
+             no_empty, no_tomb, no_used);
+  return 0;
 }
+static int efab_dlfilters_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, efab_dlfilters_read_proc, 0);
+}
+static const struct file_operations efab_dlfilters_fops = {
+    .owner   = THIS_MODULE,
+    .open    = efab_dlfilters_open_proc,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = single_release,
+};
 
 
 /****************************************************************************
  *
- * Install new proc entries, substitute existing proc entries
+ * Install new proc entries
  *
  ****************************************************************************/
 /**
- * Install read-only files into /proc/drivers/sfc as requested by the table
- * in the argument.
+ * Install read-only files into /proc/drivers/onload as requested
+ * by the table in the argument.
  */
 static void
 ci_proc_files_install(struct proc_dir_entry *root, char *root_name,
@@ -376,13 +333,13 @@
     ci_proc_efab_entry_t  *efab_entry = &entries[entry_no];
 
     OO_DEBUG_STATS(ci_log("Create %s/%s: read_proc=%p",
-                      root_name, efab_entry->name, efab_entry->read_proc));
+                      root_name, efab_entry->name, efab_entry->fops));
 
-    if (create_proc_read_entry(efab_entry->name, 0, root, 
-                               efab_entry->read_proc, 0) == NULL) {
+    if (proc_create(efab_entry->name, 0, root, efab_entry->fops)
+        == NULL) {
 
-      ci_log("Unable to create %s/%s: read_proc=%p",
-             root_name, efab_entry->name, efab_entry->read_proc);
+      ci_log("Unable to create %s/%s: fops=%p",
+             root_name, efab_entry->name, efab_entry->fops);
 
       /* we're not registering any methods off the proc entry so if we
          fail outcome is just that our entry doesn't get put into /proc
@@ -422,12 +379,7 @@
 
 
 #if CI_CFG_STATS_NETIF
-  {
-    struct proc_dir_entry *entry;
-    entry = create_proc_entry("stacks", 0, oo_proc_root);
-    if( entry )
-      entry->proc_fops = &efab_stacks_seq_fops;
-  }
+  proc_create("stacks", 0, oo_proc_root, &efab_stacks_seq_fops);
 #endif
 
 #if CI_MEMLEAK_DEBUG_ALLOC_TABLE
@@ -461,6 +413,6 @@
 #if CI_MEMLEAK_DEBUG_ALLOC_TABLE
   remove_proc_entry("mem", oo_proc_root);
 #endif
-  remove_proc_entry(oo_proc_root->name, oo_proc_root->parent);
+  remove_proc_entry("driver/onload", NULL);
   oo_proc_root = NULL;
 }
diff -ur openonload-201210-u2_orig/src/driver/linux_resource/filter.c openonload-201210-u2_patched/src/driver/linux_resource/filter.c
--- openonload-201210-u2_orig/src/driver/linux_resource/filter.c	2013-07-25 14:33:10.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_resource/filter.c	2013-09-27 10:08:52.000000000 +0100
@@ -607,6 +607,8 @@
 	}
 }
 
+static const struct file_operations efrm_fops_rules;
+
 static void efrm_add_files( efrm_filter_table_t* table )
 {
 	/* Create the /proc/ files for this table. */
@@ -620,7 +622,7 @@
 		table->efrm_ft_rules_file = efrm_proc_create_file(
 				"firewall_rules", 0444,
 				table->efrm_ft_directory,
-				efrm_read_rules, NULL, table
+				&efrm_fops_rules, table
 				);
 	}
 }
@@ -858,7 +860,7 @@
 }
 
 static ssize_t
-print_rule ( char* buf, char const* iface, int max_num,
+print_rule ( struct seq_file *seq, char const* iface,
              efrm_filter_rule_t* rule, int number )
 {
 	/* Print a rule in a human readable form (that the parser can read
@@ -869,7 +871,7 @@
 	   buffer, and handle the user reading further. */
 	char const* action_name = efrm_get_action_name( rule->efr_action );
 	if ( rule->efr_protocol == ep_eth ) {
-		return scnprintf( buf, max_num, "if=%s rule=%d protocol=eth "
+		return seq_printf( seq, "if=%s rule=%d protocol=eth "
 			"mac=%02x:%02x:%02x:%02x:%02x:%02x"
 			"/%02x:%02x:%02x:%02x:%02x:%02x action=%s\n",
 			iface ? iface : "?", number,
@@ -887,7 +889,7 @@
 			(unsigned char) rule->efrm_rule.efr_macaddess.efrm_lcl_mask[5] & 0xff,
 			action_name );
 	} else {
-		return scnprintf( buf, max_num, "if=%s rule=%d protocol=%s"
+		return seq_printf( seq, "if=%s rule=%d protocol=%s"
 			" local_ip=" CI_IP_PRINTF_FORMAT "/" CI_IP_PRINTF_FORMAT
 			" remote_ip=" CI_IP_PRINTF_FORMAT "/" CI_IP_PRINTF_FORMAT
 			" local_port=%d-%d remote_port=%d-%d action=%s\n",
@@ -906,29 +908,21 @@
 }
 
 static ssize_t
-efrm_print_all_rules( efrm_filter_table_t* table, char* buf, int max_bytes )
+efrm_print_all_rules( efrm_filter_table_t* table, struct seq_file *seq)
 {
 	/* Print all the rules from a table into the given buffer. */
 	efrm_filter_rule_t* rule;
 	int rule_number = 0;
-	char* next_buf = buf;
-	int bytes_remaining = max_bytes;
-	ssize_t total_bytes_used = 0;
 
-	if ( !table || !buf || !max_bytes )
+	if ( !table )
 		return 0;
 
 	rule = table->efrm_ft_first_rule;
-	while ( rule && total_bytes_used < bytes_remaining ) {
-		int bytes_used = print_rule(next_buf,
-				    table->efrm_ft_interface_name,
-				    bytes_remaining-total_bytes_used,
-				    rule, rule_number++ );
-		next_buf += bytes_used;
-		total_bytes_used += bytes_used;
-		rule = rule->efrm_fr_next;
+	while ( rule ) {
+		print_rule(seq, table->efrm_ft_interface_name,
+			   rule, rule_number++ );
 	}
-	return total_bytes_used;
+	return 0;
 }
 
 /* TODO: I think these can be included now, rather than copied here */
@@ -1293,8 +1287,8 @@
 /* /proc/driver/sfc_resource/ */
 /* ************************** */
 
-int efrm_add_rule(struct file *file, const char *buf, unsigned long count,
-		  void *data)
+ssize_t efrm_add_rule(struct file *file, const char __user *buf,
+		      size_t count, loff_t *ppos)
 {
     /* ENTRYPOINT from firewall_add
        Interpret the provided buffer, and add the rules therein. */
@@ -1343,9 +1337,13 @@
     mutex_unlock( &efrm_ft_mutex );
     return count;
 }
+static const struct file_operations efrm_fops_add_rule = {
+	.owner		= THIS_MODULE,
+	.write		= efrm_add_rule,
+};
 
-int efrm_del_rule(struct file *file, const char *buf, unsigned long count,
-		  void *data)
+ssize_t efrm_del_rule(struct file *file, const char __user *buf,
+		      size_t count, loff_t *ppos)
 {
 	/* ENTRYPOINT from firewall_del.
 	   Interpret the buffer and delete the specified rule(s) */
@@ -1397,28 +1395,39 @@
 	}
 	return count;
 }
+static const struct file_operations efrm_fops_del_rule = {
+	.owner		= THIS_MODULE,
+	.write		= efrm_del_rule,
+};
 
 /* ******************************* */
 /* /proc/driver/sfc_resource/ethX/ */
 /* ******************************* */
 
-int
-efrm_read_rules(char *buffer,
-	      char **buffer_location,
-	      off_t offset, int buffer_length, int *eof, void *data)
+static int
+efrm_read_rules(struct seq_file *seq, void *s)
 {
 	/* Entry point from /proc/driver/sfc_resource/ethX/firewall_rules */
 	/* TODO: We may need to support offset if there are many rules */
-	efrm_filter_table_t* table = (efrm_filter_table_t*) data;
-	ssize_t bytes_used = 0;
+	efrm_filter_table_t* table = (efrm_filter_table_t*) seq->private;
 	
-	if ( !buffer || buffer_length < 0 || !table || !eof )
+	if ( !table )
 		return -EINVAL;
 	
-	bytes_used = efrm_print_all_rules( table, buffer, buffer_length );
-	*eof = 1;
-	return bytes_used;
+	efrm_print_all_rules( table, seq );
+	return 0;
+}
+static int efrm_open_rules(struct inode *inode, struct file *file)
+{
+	return single_open(file, efrm_read_rules, 0);
 }
+static const struct file_operations efrm_fops_rules = {
+	.owner		= THIS_MODULE,
+	.open		= efrm_open_rules,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 /* ***************************************** */
 /* Initialisation and shutdown entry points. */
@@ -1457,9 +1466,9 @@
 {
 	/* Add the /proc/ files that are not per-interface. */
 	efrm_pd_add_rule = efrm_proc_create_file( "firewall_add", 0200,
-					NULL, NULL, efrm_add_rule, NULL );
+					NULL, &efrm_fops_add_rule, NULL );
 	efrm_pd_del_rule = efrm_proc_create_file( "firewall_del", 0200,
-					NULL, NULL, efrm_del_rule, NULL );
+					NULL, &efrm_fops_del_rule, NULL );
 }
 
 void efrm_filter_remove_proc_entries()
diff -ur openonload-201210-u2_orig/src/driver/linux_resource/kernel_compat.h openonload-201210-u2_patched/src/driver/linux_resource/kernel_compat.h
--- openonload-201210-u2_orig/src/driver/linux_resource/kernel_compat.h	2013-07-25 14:33:10.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_resource/kernel_compat.h	2013-09-27 10:08:52.000000000 +0100
@@ -190,4 +190,54 @@
 # define f_vfsmnt f_path.mnt
 #endif
 
+
+
+/* For all kernels, we use 3.10 seq API for proc files */
+#include <linux/proc_fs.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+#ifdef RHEL_MAJOR
+static inline struct proc_dir_entry *
+proc_create_data(const char *name, umode_t mode,
+         struct proc_dir_entry *parent,
+         const struct file_operations *proc_fops,
+         void *data)
+{
+    struct proc_dir_entry *pde;
+    pde = proc_create(name, mode, parent, proc_fops);
+    if (pde != NULL)
+        pde->data = data;
+    return pde;
+}
+#else
+static inline struct proc_dir_entry *
+proc_create_data(const char *name, umode_t mode,
+		 struct proc_dir_entry *parent,
+		 const struct file_operations *proc_fops,
+		 void *data)
+{
+	struct proc_dir_entry *pde;
+	pde = create_proc_entry(name, mode, parent);
+	if (pde != NULL) {
+		pde->proc_fops = (struct file_operations *)proc_fops;
+		pde->data = data;
+	}
+	return pde;
+}
+static inline struct proc_dir_entry *
+proc_create(const char *name, umode_t mode,
+		 struct proc_dir_entry *parent,
+		 const struct file_operations *proc_fops)
+{
+	return proc_create_data(name, mode, parent, proc_fops, NULL);
+}
+#endif
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+static inline void *PDE_DATA(const struct inode *inode)
+{
+	return PROC_I(inode)->pde->data;
+}
+#endif
+
+
 #endif /* DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H */
diff -ur openonload-201210-u2_orig/src/driver/linux_resource/kernel_proc.c openonload-201210-u2_patched/src/driver/linux_resource/kernel_proc.c
--- openonload-201210-u2_orig/src/driver/linux_resource/kernel_proc.c	2013-07-25 14:33:10.000000000 +0100
+++ openonload-201210-u2_patched/src/driver/linux_resource/kernel_proc.c	2013-09-27 10:08:52.000000000 +0100
@@ -54,6 +54,7 @@
 #include <ci/efrm/driver_private.h>
 #include <ci/efrm/kernel_proc.h>
 #include <linux/proc_fs.h>
+#include "kernel_compat.h"
 
 /** Top level directory for sfc specific stats **/
 static struct proc_dir_entry *efrm_proc_root = NULL;
@@ -83,13 +84,6 @@
  *
  ****************************************************************************/
 
-void efrm_pd_set_owner( struct proc_dir_entry* dir_entry )
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
-	dir_entry->owner = THIS_MODULE;
-#endif
-}
-
 efrm_pd_handle efrm_proc_dir_get(char const* dirname)
 {
 	/* Acquire a handle to a directory; creates the directory if needed */
@@ -173,8 +167,8 @@
 				}
 				/* Delete the directory and table entry*/
 				/* TODO: Warn if it still has files in it */
-				remove_proc_entry(procdir->efrm_pd_dir->name,
-						procdir->efrm_pd_dir->parent);
+				remove_proc_entry(procdir->efrm_pd_name,
+						  efrm_proc_root);
 				kfree( procdir );
 			}
 			rval = 0;
@@ -191,7 +185,7 @@
 
 efrm_pd_handle
 efrm_proc_create_file( char const* name, mode_t mode, efrm_pd_handle parent,
-                       read_proc_t* read_proc, write_proc_t* write_proc,
+                       const struct file_operations *fops,
                        void* context )
 {
 	/* Tracking the files within a /proc/ directory. */
@@ -217,17 +211,13 @@
 	strlcpy( rval->efrm_pf_name, name, IFNAMSIZ );
 	rval->efrm_pf_next = handle ? handle->efrm_pd_child : NULL;
 	
-	entry = create_proc_entry( name, mode, root );
+	entry = proc_create_data( name, mode, root, fops, context );
 	if ( !entry ) {
 		EFRM_WARN("%s: Unable to create procfile %s", __func__, name);
 		kfree( rval );
 		rval = NULL;
 	}
 	else {
-		entry->data = context;
-		entry->read_proc = read_proc;
-		entry->write_proc = write_proc;
-		efrm_pd_set_owner(entry);
 		rval->efrm_pf_file = entry;
 		if ( handle ) {
 			rval->efrm_pf_next = handle->efrm_pd_child;
@@ -251,7 +241,9 @@
 
 	if ( entry && entry->efrm_pf_file ) {
 		remove_proc_entry( entry->efrm_pf_name,
-		                   entry->efrm_pf_file->parent );
+				   entry->efrm_pf_parent ?
+				   entry->efrm_pf_parent->efrm_pd_dir :
+				   efrm_proc_root);
 		parent = entry->efrm_pf_parent;
 		if ( parent ) {
 			/* remove ourselves from the list of children */
@@ -292,8 +284,7 @@
 		rval = 0;
 		/* Which is worse, to leak these, or to destroy them while
 		   somthing is holding a handle? */
-		remove_proc_entry(procdir->efrm_pd_dir->name,
-		                  procdir->efrm_pd_dir->parent);
+		remove_proc_entry(procdir->efrm_pd_name, efrm_proc_root);
 		/* Delete the table entry*/
 		kfree( procdir );
 		procdir = next;
@@ -311,9 +302,7 @@
  ****************************************************************************/
 
 
-static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data);
+static const struct file_operations efrm_resource_fops_proc;
 
 int efrm_install_proc_entries(void)
 {
@@ -326,14 +315,10 @@
 			rc = -ENOMEM;
 		}
 		else {
-			efrm_pd_set_owner(efrm_proc_root);
-			efrm_proc_resources = create_proc_read_entry(
+			efrm_proc_resources = proc_create(
 					"resources", 0, efrm_proc_root,
-					efrm_resource_read_proc, 0);
-			if ( efrm_proc_resources ) {
-				efrm_pd_set_owner(efrm_proc_resources);
-			}
-			else {
+					&efrm_resource_fops_proc);
+			if ( !efrm_proc_resources ) {
 				EFRM_WARN("%s: Unable to create /proc/drivers/"
 					  "sfc_resource/resources", __func__);
 			}
@@ -359,10 +344,10 @@
 	}
 
 	if ( efrm_proc_resources )
-		remove_proc_entry(efrm_proc_resources->name, efrm_proc_root);
+		remove_proc_entry("resources", efrm_proc_root);
 	efrm_proc_resources = NULL;
 	if ( efrm_proc_root )
-		remove_proc_entry(efrm_proc_root->name, efrm_proc_root->parent);
+		remove_proc_entry("driver/sfc_resource", NULL);
 	efrm_proc_root = NULL;
 
 done_efrm_uninstall_proc_entries:
@@ -376,18 +361,9 @@
  *
  ****************************************************************************/
 
-#define EFRM_PROC_PRINTF(buf, len, fmt, ...)				\
-	do {								\
-		if (count - len > 0)					\
-			len += snprintf(buf+len, count-len, (fmt),	\
-					__VA_ARGS__);			\
-	} while (0)
-
 static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data)
+efrm_resource_read_proc(struct seq_file *seq, void *s)
 {
-	int len = 0;
 	int type;
 	struct efrm_resource_manager *rm;
 
@@ -396,15 +372,26 @@
 		if (rm == NULL)
 			continue;
 
-		EFRM_PROC_PRINTF(buf, len, "*** %s ***\n", rm->rm_name);
+		seq_printf(seq, "*** %s ***\n", rm->rm_name);
 
 		spin_lock_bh(&rm->rm_lock);
-		EFRM_PROC_PRINTF(buf, len, "current = %u\n", rm->rm_resources);
-		EFRM_PROC_PRINTF(buf, len, "    max = %u\n\n",
+		seq_printf(seq, "current = %u\n", rm->rm_resources);
+		seq_printf(seq, "    max = %u\n\n",
 				 rm->rm_resources_hiwat);
 		spin_unlock_bh(&rm->rm_lock);
 	}
 
-	return count ? strlen(buf) : 0;
+	return 0;
 }
+static int efrm_resource_open_proc(struct inode *inode, struct file *file)
+{
+	return single_open(file, efrm_resource_read_proc, PDE_DATA(inode));
+}
+static const struct file_operations efrm_resource_fops_proc = {
+	.owner		= THIS_MODULE,
+	.open		= efrm_resource_open_proc,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
diff -ur openonload-201210-u2_orig/src/include/ci/driver/platform/linux_cplane_sync.h openonload-201210-u2_patched/src/include/ci/driver/platform/linux_cplane_sync.h
--- openonload-201210-u2_orig/src/include/ci/driver/platform/linux_cplane_sync.h	2013-07-25 14:33:12.000000000 +0100
+++ openonload-201210-u2_patched/src/include/ci/driver/platform/linux_cplane_sync.h	2013-09-27 10:08:52.000000000 +0100
@@ -201,9 +201,7 @@
  * /proc statistics
  *---------------------------------------------------------------------------*/
 
-extern int 
-cicp_stat_read_proc(char *buf, char **start, off_t offset, int count, int *eof,
-                    void *data);
+extern const struct file_operations cicp_stat_fops;
 
 
 /*----------------------------------------------------------------------------
diff -ur openonload-201210-u2_orig/src/include/ci/efrm/efrm_filter.h openonload-201210-u2_patched/src/include/ci/efrm/efrm_filter.h
--- openonload-201210-u2_orig/src/include/ci/efrm/efrm_filter.h	2013-07-25 14:33:13.000000000 +0100
+++ openonload-201210-u2_patched/src/include/ci/efrm/efrm_filter.h	2013-09-27 10:08:52.000000000 +0100
@@ -70,11 +70,4 @@
 extern void efrm_init_resource_filter(struct device *dev, int ifindex);
 extern void efrm_shutdown_resource_filter(struct device *dev);
 
-/* Access fucntions for /proc/ */
-extern int
-efrm_read_rules(char *buffer,
-		char **buffer_location,
-		off_t offset, int buffer_length, int *eof, void *data);
-
-
 #endif /* __CI_EFRM_FILTER_H__ */
diff -ur openonload-201210-u2_orig/src/include/ci/efrm/kernel_proc.h openonload-201210-u2_patched/src/include/ci/efrm/kernel_proc.h
--- openonload-201210-u2_orig/src/include/ci/efrm/kernel_proc.h	2013-07-25 14:33:13.000000000 +0100
+++ openonload-201210-u2_patched/src/include/ci/efrm/kernel_proc.h	2013-09-27 10:08:52.000000000 +0100
@@ -53,8 +53,8 @@
 #ifndef __CI_EFRM_KERNEL_PROC_H__
 #define __CI_EFRM_KERNEL_PROC_H__
 
-/* For read_proc and write_proc */
-#include <linux/proc_fs.h>
+/* For file_operations */
+#include <linux/fs.h>
 
 typedef void* efrm_pd_handle;
 
@@ -63,7 +63,7 @@
 
 efrm_pd_handle
 efrm_proc_create_file( char const* name, mode_t mode, efrm_pd_handle parent,
-                       read_proc_t* read_proc, write_proc_t* write_proc,
+                       const struct file_operations *fops,
                        void* context );
 extern void efrm_proc_remove_file( efrm_pd_handle handle );
 
diff -ur openonload-201210-u2_orig/src/include/onload/iobufset.h openonload-201210-u2_patched/src/include/onload/iobufset.h
--- openonload-201210-u2_orig/src/include/onload/iobufset.h	2013-07-25 14:33:12.000000000 +0100
+++ openonload-201210-u2_patched/src/include/onload/iobufset.h	2013-09-27 10:09:10.000000000 +0100
@@ -56,6 +56,7 @@
 #include <onload/common.h>
 #include <onload/linux_onload.h>
 #include <onload/atomics.h>
+#include <ci/driver/efab/workqueue.h>
 
 /********************************************************************
  *
@@ -99,6 +100,7 @@
   int shmid;
 #ifdef CLONE_NEWIPC
   struct ipc_namespace *ipc_ns;
+  ci_workitem_t wi;
 #endif
 #endif
   struct page **pages;     /*!< array of Linux compound pages */
Only in openonload-201210-u2_patched/src/include/onload: iobufset.h.orig
diff -ur openonload-201210-u2_orig/src/lib/efthrm/iobufset.c openonload-201210-u2_patched/src/lib/efthrm/iobufset.c
--- openonload-201210-u2_orig/src/lib/efthrm/iobufset.c	2013-07-25 14:33:09.000000000 +0100
+++ openonload-201210-u2_patched/src/lib/efthrm/iobufset.c	2013-09-27 10:09:10.000000000 +0100
@@ -58,10 +58,19 @@
 #include <ci/efrm/pd.h>
 #include <onload/iobufset.h>
 #include <onload/debug.h>
+#include <onload/tcp_driver.h>
 
 
 /************** IO page operations ****************/
 
+static void oo_iobufset_kfree(struct oo_buffer_pages *pages)
+{
+
+  if( (void *)(pages + 1) != (void *)pages->pages )
+    kfree(pages->pages);
+  kfree(pages);
+}
+
 #ifdef OO_DO_HUGE_PAGES
 
 #ifdef CLONE_NEWIPC
@@ -235,7 +244,11 @@
   ci_assert(p->shmid >= 0);
   ci_assert(current);
 #ifdef CLONE_NEWIPC
-  if( CI_UNLIKELY( current->nsproxy->ipc_ns != p->ipc_ns ) ) {
+  if( current->nsproxy == NULL ) {
+    ci_workitem_init(&p->wi, (CI_WITEM_ROUTINE)oo_bufpage_huge_free, p);
+    ci_workqueue_add(&CI_GLOBAL_WORKQUEUE, &p->wi);
+  }
+  else if( CI_UNLIKELY( current->nsproxy->ipc_ns != p->ipc_ns ) ) {
     /* Ideally, we'd like to call switch_task_namespaces() to get old
      * namespace - but it is not exported.
      * Moreover, it may be destroyed - (get|put)_ipc_ns() are not exported
@@ -243,12 +256,15 @@
     ci_log("Onload does not support applications which use CLONE_NEWIPC "
            "together with huge pages.");
     ci_log("Leaking 1 huge page.");
+    put_page(p->pages[0]);
+    oo_iobufset_kfree(p);
   }
   else
 #endif
   {
     put_page(p->pages[0]);
     efab_linux_sys_shmctl(p->shmid, IPC_RMID, NULL);
+    oo_iobufset_kfree(p);
   }
 }
 #endif
@@ -268,11 +284,8 @@
 
     for (i = 0; i < pages->n_bufs; ++i)
       __free_pages(pages->pages[i], compound_order(pages->pages[i]));
+    oo_iobufset_kfree(pages);
   }
-
-  if( (void *)(pages + 1) != (void *)pages->pages )
-    kfree(pages->pages);
-  kfree(pages);
 }
 
 static int oo_bufpage_alloc(struct oo_buffer_pages **pages_out,
Only in openonload-201210-u2_patched/src/lib/efthrm: iobufset.c.orig
Only in openonload-201210-u2_patched/: unified.patch
